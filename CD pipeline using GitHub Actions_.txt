#!/usr/bin/env bash
set -euo pipefail

# fullstack-ci-cd-single-file.sh
# Single-file project generator for a minimal full-stack React + Express app
# Includes:
# - client/ (React app using react-scripts)
# - server/ (Express API serving /api and static frontend)
# - multi-stage Dockerfile (build frontend, install server deps, produce small runtime image)
# - .dockerignore
# - GitHub Actions workflows: .github/workflows/ci.yml and cd.yml (push to GHCR)
#
# Usage:
# 1) Make executable: chmod +x fullstack-ci-cd-single-file.sh
# 2) Run to scaffold the project: ./fullstack-ci-cd-single-file.sh
# 3) Optionally run: ./fullstack-ci-cd-single-file.sh --build to run npm installs, build frontend, and build docker image
#
# Note: The script attempts to avoid running heavy operations unless you pass --build.

APP_DIR="fullstack-react-express"
IMAGE_NAME="my-fullstack-app:latest"
HOST_PORT=3000
RUN_BUILD=0

for arg in "$@"; do
  case "$arg" in
    --build) RUN_BUILD=1 ;; 
    --image=*) IMAGE_NAME="${arg#--image=}" ;;
    --port=*) HOST_PORT="${arg#--port=}" ;;
    -h|--help) echo "Usage: $0 [--build] [--image=name:tag] [--port=PORT]"; exit 0 ;;
  esac
done

# Check prerequisites if building
if [ "$RUN_BUILD" -eq 1 ]; then
  command -v node >/dev/null 2>&1 || { echo "Node.js is required for --build. Install Node.js (v16+)."; exit 1; }
  command -v npm >/dev/null 2>&1 || { echo "npm is required for --build. Install Node.js/npm."; exit 1; }
  command -v docker >/dev/null 2>&1 || { echo "Docker is required for --build. Install Docker and ensure it is running."; exit 1; }
fi

# Remove existing and create directory
rm -rf "$APP_DIR"
mkdir -p "$APP_DIR"
cd "$APP_DIR"

#########################
# Root README
#########################
cat > README.md <<'MD'
# Fullstack React + Express (single-file scaffold)

This repo was generated by `fullstack-ci-cd-single-file.sh`.

Structure:
- client/         # React app created with react-scripts
- server/         # Express server exposing /api and serving built frontend
- Dockerfile      # multi-stage Dockerfile building client and server
- .github/workflows/ci.yml  # CI: test & build
- .github/workflows/cd.yml  # CD: build & push Docker image to GHCR

Quick dev:
  cd server
  npm install
  cd ../client
  npm install
  npm start

To build the Docker image locally (multi-stage image):
  docker build -t my-fullstack-app:latest .
  docker run --rm -p 3000:3000 my-fullstack-app:latest

Note: the CI/CD workflows use GitHub Container Registry (GHCR). The `cd.yml` uses the built-in GITHUB_TOKEN and requires `permissions: packages: write`.
MD

#########################
# Server (Express)
#########################
mkdir -p server
cat > server/package.json <<'JSON'
{
  "name": "fullstack-server",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "NODE_ENV=development nodemon index.js",
    "test": "node test.js || true"
  },
  "dependencies": {
    "express": "^4.18.2",
    "path": "^0.12.7"
  },
  "devDependencies": {
    "nodemon": "^2.0.22"
  }
}
JSON

cat > server/index.js <<'NODE'
const express = require('express');
const path = require('path');
const app = express();
const PORT = process.env.PORT || 3000;

// Simple API
app.get('/api/hello', (req, res) => {
  res.json({ message: 'Hello from Express API!' });
});

// Serve static files from client build
const clientBuildPath = path.join(__dirname, '..', 'client', 'build');
app.use(express.static(clientBuildPath));

app.get('*', (req, res) => {
  // If request starts with /api, send 404 (not matched above)
  if (req.path.startsWith('/api')) return res.status(404).json({ error: 'Not found' });
  res.sendFile(path.join(clientBuildPath, 'index.html'));
});

app.listen(PORT, () => console.log(`Server listening on port ${PORT}`));
NODE

cat > server/test.js <<'TEST'
// Minimal smoke test for the server (no external libs)
const http = require('http');
const req = http.request({ host: 'localhost', port: 3000, path: '/api/hello', method: 'GET', timeout: 1000 }, res => {
  console.log('server test: status', res.statusCode);
  process.exit(0);
});
req.on('error', () => process.exit(1));
req.end();
TEST

#########################
# Client (React)
#########################
npx --version >/dev/null 2>&1 || true
mkdir -p client/public client/src
cat > client/package.json <<'JSON'
{
  "name": "fullstack-client",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "react-scripts": "5.0.1",
    "axios": "1.4.0"
  },
  "scripts": {
    "start": "PORT=3001 react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --watchAll=false --env=jsdom"
  }
}
JSON

cat > client/public/index.html <<'HTML'
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fullstack React + Express</title>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
HTML

cat > client/src/index.js <<'JS'
import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';
import './index.css';

const root = createRoot(document.getElementById('root'));
root.render(<App />);
JS

cat > client/src/App.js <<'JS'
import React, {useEffect, useState} from 'react';
import axios from 'axios';

export default function App(){
  const [msg, setMsg] = useState('Loading...');

  useEffect(()=>{
    axios.get('/api/hello')
      .then(r=> setMsg(r.data.message))
      .catch(()=> setMsg('Could not reach API'));
  },[]);

  return (
    <div style={{fontFamily:'Arial', padding:20}}>
      <h1>Fullstack React + Express</h1>
      <p>API message: <strong>{msg}</strong></p>
      <p>This demo is scaffolded by a single-file generator including CI/CD workflows.</p>
    </div>
  );
}
JS

cat > client/src/index.css <<'CSS'
body { margin: 0; font-family: Arial, sans-serif; }
CSS

#########################
# Dockerfile (multi-stage)
#########################
cat > Dockerfile <<'DOCKER'
# ---- Build client ----
FROM node:18-alpine AS client-build
WORKDIR /app/client
COPY client/package.json client/package-lock.json* ./
RUN if [ -f package-lock.json ]; then npm ci --silent; else npm install --silent; fi
COPY client/ ./
RUN npm run build

# ---- Build server (install deps) ----
FROM node:18-alpine AS server-build
WORKDIR /app/server
COPY server/package.json server/package-lock.json* ./
RUN if [ -f package-lock.json ]; then npm ci --silent --production; else npm install --silent --production; fi
COPY server/ ./

# Copy client build into server static folder
COPY --from=client-build /app/client/build /app/server/build

# ---- Runtime image ----
FROM node:18-alpine AS runtime
WORKDIR /app
ENV NODE_ENV=production
COPY --from=server-build /app/server /app
EXPOSE 3000
CMD ["node", "index.js"]
DOCKER

#########################
# .dockerignore
#########################
cat > .dockerignore <<'DOCKERIGNORE'
node_modules
client/node_modules
server/node_modules
.git
.gitignore
Dockerfile
.dockerignore
Dockerfile*
README.md
.dockerignore
DOCKERIGNORE

#########################
# GitHub Actions: CI
#########################
mkdir -p .github/workflows
cat > .github/workflows/ci.yml <<'CI'
name: CI

on:
  push:
    branches: [ '**' ]
  pull_request:
    branches: [ '**' ]

jobs:
  test-and-build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18]

    steps:
      - uses: actions/checkout@v4

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      - name: Install server dependencies
        run: |
          cd server
          npm ci

      - name: Install client dependencies
        run: |
          cd client
          npm ci

      - name: Run server tests (smoke)
        run: |
          cd server
          npm test || true

      - name: Run client tests
        run: |
          cd client
          npm test || true

      - name: Build client
        run: |
          cd client
          npm run build

      - name: Upload client build artifact
        uses: actions/upload-artifact@v4
        with:
          name: client-build
          path: client/build
CI

#########################
# GitHub Actions: CD (push Docker to GHCR)
#########################
cat > .github/workflows/cd.yml <<'CD'
name: CD

on:
  push:
    branches:
      - main

permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/${{ github.repository }}:latest
            ghcr.io/${{ github.repository_owner }}/${{ github.repository }}:${{ github.sha }}
          cache-from: type=registry,ref=ghcr.io/${{ github.repository_owner }}/${{ github.repository }}:cache
          cache-to: type=registry,ref=ghcr.io/${{ github.repository_owner }}/${{ github.repository }}:cache,mode=max

  # Optional: SSH deploy step (commented out)
  # deploy:
  #   needs: build-and-push-image
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Deploy via SSH
  #       uses: appleboy/ssh-action@v0.1.9
  #       with:
  #         host: ${{ secrets.SSH_HOST }}
  #         username: ${{ secrets.SSH_USER }}
  #         key: ${{ secrets.SSH_PRIVATE_KEY }}
  #         script: |
  #           docker pull ghcr.io/${{ github.repository_owner }}/${{ github.repository }}:latest
  #           docker stop fullstack-app || true
  #           docker rm fullstack-app || true
  #           docker run -d --restart unless-stopped -p 80:3000 --name fullstack-app ghcr.io/${{ github.repository_owner }}/${{ github.repository }}:latest
CD

#########################
# Makefile (optional convenience)
#########################
cat > Makefile <<'MAKE'
.PHONY: install-client install-server build-client build docker-run

install-server:
	cd server && npm install

install-client:
	cd client && npm install

build-client:
	cd client && npm run build

build:
	docker build -t ${IMAGE_NAME} .

docker-run:
	docker run --rm -p ${HOST_PORT}:3000 ${IMAGE_NAME}
MAKE

#########################
# Final instructions
#########################
cat > SCAFFOLDING_NOTES.txt <<'TXT'
Scaffold created.

To run locally in development:
  1) Install server & client deps
     cd server && npm install
     cd ../client && npm install
  2) Run server (serves built frontend)
     cd server && npm run dev
  3) Run client (in a separate terminal, for HMR)
     cd client && npm start

To build and run production Docker image locally:
  docker build -t my-fullstack-app:latest .
  docker run --rm -p 3000:3000 my-fullstack-app:latest

CI/CD:
- Push this repository to GitHub. The CI workflow (.github/workflows/ci.yml) will run on push/PR.
- When you push to the `main` branch, the CD workflow (.github/workflows/cd.yml) will build and push the Docker image to GHCR (ghcr.io).

Secrets: For optional SSH deploy uncomment and set secrets: SSH_HOST, SSH_USER, SSH_PRIVATE_KEY in repo settings.
TXT

#########################
# Run optional build steps
#########################
if [ "$RUN_BUILD" -eq 1 ]; then
  echo "\nInstalling server dependencies..."
  (cd server && npm ci)
  echo "\nInstalling client dependencies... (this may take a couple minutes)"
  (cd client && npm ci)
  echo "\nBuilding client..."
  (cd client && npm run build)

  echo "\nBuilding Docker image: ${IMAGE_NAME}"
  docker build -t "${IMAGE_NAME}" .
  echo "\nTo run locally: docker run --rm -p ${HOST_PORT}:3000 ${IMAGE_NAME}"
else
  echo "\nScaffold created in ./${APP_DIR}. To build and run, re-run this script with --build or follow the SCAFFOLDING_NOTES.txt file."
fi

# End

echo "\nDone."
